'use strict';

var react = require('react');

class ChatbotAPI {
    constructor(config) {
        this.apiKey = config.apiKey;
        // âœ… Robust fallback - NO process.env
        if (config.apiBaseUrl && typeof config.apiBaseUrl === 'string' && config.apiBaseUrl.trim() !== '') {
            this.baseUrl = config.apiBaseUrl.trim();
        }
        else {
            this.baseUrl = 'https://sdk-backend-teaa.onrender.com';
        }
        this.productContext = config.productContext;
        this.sessionId = config.sessionId || this.generateSessionId();
        console.log('ChatbotAPI baseUrl:', this.baseUrl);
    }
    generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        console.log('Request URL:', url);
        const response = await fetch(url, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                'X-API-Key': this.apiKey,
                ...options.headers,
            },
        });
        if (!response.ok) {
            const error = await response.json().catch(() => ({ error: 'Unknown error' }));
            throw new Error(error.error || `HTTP ${response.status}`);
        }
        return response.json();
    }
    async sendMessage(message) {
        const data = await this.request('/api/v1/chat', {
            method: 'POST',
            body: JSON.stringify({
                message,
                product_context: this.productContext,
                session_id: this.sessionId,
            }),
        });
        return data.response;
    }
    async getSuggestedQuestions() {
        return this.request('/api/v1/questions', {
            method: 'POST',
            body: JSON.stringify({
                sku: this.productContext.sku,
            }),
        });
    }
    async getWidgetConfig() {
        return this.request('/api/v1/config');
    }
    updateProductContext(newContext) {
        this.productContext = { ...this.productContext, ...newContext };
    }
}

function useChat(options) {
    const [messages, setMessages] = react.useState([]);
    const [isLoading, setIsLoading] = react.useState(false);
    const [isBotTyping, setIsBotTyping] = react.useState(false);
    const [suggestedQuestions, setSuggestedQuestions] = react.useState([]);
    const [error, setError] = react.useState(null);
    const apiClientRef = react.useRef(null);
    react.useEffect(() => {
        apiClientRef.current = new ChatbotAPI({
            apiKey: options.apiKey,
            productContext: options.productContext,
            apiBaseUrl: options.apiBaseUrl,
        });
        const fetchQuestions = async () => {
            try {
                const questions = await apiClientRef.current.getSuggestedQuestions();
                setSuggestedQuestions(questions);
            }
            catch (err) {
                console.error('Failed to fetch suggested questions:', err);
            }
        };
        fetchQuestions();
    }, [options.apiKey, options.productContext.sku, options.apiBaseUrl]);
    const sendMessage = react.useCallback(async (messageText) => {
        if (!messageText.trim() || !apiClientRef.current)
            return;
        const userMessage = {
            sender: 'user',
            text: messageText,
            timestamp: Date.now(),
        };
        setMessages((prev) => [...prev, userMessage]);
        setIsLoading(true);
        setIsBotTyping(true);
        setError(null);
        try {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            const response = await apiClientRef.current.sendMessage(messageText);
            const botMessage = {
                sender: 'chatbot',
                text: response,
                timestamp: Date.now(),
            };
            setMessages((prev) => [...prev, botMessage]);
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error('Unknown error');
            setError(error);
            if (options.onError) {
                options.onError(error);
            }
            const errorMessage = {
                sender: 'chatbot',
                text: 'Sorry, something went wrong. Please try again.',
                timestamp: Date.now(),
            };
            setMessages((prev) => [...prev, errorMessage]);
        }
        finally {
            setIsLoading(false);
            setIsBotTyping(false);
        }
    }, [options]);
    const clearMessages = react.useCallback(() => {
        setMessages([]);
        setError(null);
    }, []);
    return {
        messages,
        sendMessage,
        isLoading,
        isBotTyping,
        suggestedQuestions,
        error,
        clearMessages,
    };
}

function formatTimestamp(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}
function validateConfig(config) {
    return !!(config.apiKey && config.productContext);
}

function extractProductFromPage() {
    const extractors = [
        extractFromStructuredData,
        extractFromOpenGraph,
        extractFromShopify,
        extractFromWooCommerce,
        extractFromDOM
    ];
    let productData = {};
    for (const extractor of extractors) {
        try {
            const data = extractor();
            productData = { ...productData, ...data };
        }
        catch (error) {
            console.debug("Extractor failed", extractor.name, error);
        }
    }
    if (!productData.sku) {
        productData.sku = generateFallbackSKU();
    }
    if (!productData.name) {
        productData.name = extractFromTitle() || "Unknown product";
    }
    return productData;
}
function extractFromStructuredData() {
    const scripts = document.querySelectorAll('script[type="application/ld+json"]');
    for (const script of Array.from(scripts)) {
        try {
            const data = JSON.parse(script.textContent || "");
            if (data["@type"] == 'Product' || data["@type"]?.includes("Product")) {
                return {
                    sku: data.sku || data.productID || data.mpn,
                    name: data.name,
                    description: data.description,
                    price: parseFloat(data.offers?.price || data.price),
                    currency: data.offers?.priceCurrency,
                    brand: data.brand?.name || data.brand,
                    images: Array.isArray(data.image) ? data.image : [data.image],
                    url: data.url || window.location.href,
                    inStock: data.offers?.availability?.includes('InStock') || data.offers?.availability === 'https://schema.org/InStock',
                };
            }
        }
        catch (error) {
            console.debug("Failed to parse structured data", error);
        }
    }
    return {};
}
function extractFromOpenGraph() {
    const getMeta = (property) => {
        const tag = document.querySelector(`meta[property="${property}"]`) ||
            document.querySelector(`meta[name="${property}"]`);
        return tag?.getAttribute('content') || undefined;
    };
    return {
        name: getMeta('og:title') || getMeta('twitter:title'),
        description: getMeta('og:description') || getMeta('twitter:description') || getMeta('description'),
        images: [getMeta('og:image') || getMeta('twitter:image')].filter(Boolean),
        url: getMeta('og:url') || window.location.href,
        price: parseFloat(getMeta('product:price:amount') || '0') || undefined,
        currency: getMeta('product:price:currency')
    };
}
function extractFromShopify() {
    const shopify = window.ShopifyAnalytics?.meta?.product;
    const product = window.product;
    if (shopify || product) {
        const data = shopify || product;
        return {
            sku: data.variants?.[0]?.sku || data.sku,
            name: data.title || data.name,
            description: data.description,
            price: data.price ? parseFloat(data.price) / 100 : undefined,
            category: data.type || data.product_type,
            brand: data.vendor,
            images: data.images?.map((img) => img.src || img) || [],
            inStock: data.available
        };
    }
    const getShopifyMeta = (name) => {
        return document.querySelector(`meta[name="shopify-${name}"]`)?.getAttribute('content');
    };
    return {
        sku: getShopifyMeta('product-sku'),
        name: getShopifyMeta('product-name')
    };
}
function extractFromWooCommerce() {
    const productElement = document.querySelector('.product, [itemtype*="schema.org/Product"]');
    if (!productElement)
        return {};
    return {
        sku: productElement.querySelector('.sku')?.textContent?.trim(),
        name: productElement.querySelector('.product_title, .product-title')?.textContent?.trim(),
        description: productElement.querySelector('woocommerce-product-details__short-description')?.textContent?.trim(),
        price: parseFloat(productElement.querySelector('.price .amount, .price')?.textContent?.replace(/[^0-9.]/g, '') || '0') || undefined,
        category: productElement.querySelector('.posted_in a')?.textContent?.trim(),
        brand: productElement.querySelector('.brand')?.textContent?.trim(),
        images: Array.from(productElement.querySelectorAll('.woocommerce-product-gallery__image img'))
            .map(img => img.src),
        inStock: !productElement.querySelector('.out-of-stock'),
    };
}
function extractFromDOM() {
    const selectors = {
        name: [
            "h1.product-title",
            "h1.product.product-name",
            'h1[itemprop="name"]',
            '.product-title',
            '.product-name',
            'h1'
        ],
        price: [
            '[itemprop="price"]',
            '.price',
            '.product-price',
            '.current-price',
            '[data-product-price]'
        ],
        description: [
            '[itemprop="description"]',
            '.product-description',
            '.description',
            '.product-details'
        ],
        sku: [
            '[itemprop="sku"]',
            '.sku',
            '.product-sku',
            '[data-product-sku]'
        ],
        images: [
            '[itemprop="images"]',
            '.product-image img',
            '.main-image img',
            '[data-product-image]',
        ]
    };
    const findFirst = (selectorList) => {
        for (const selector of selectorList) {
            const element = document.querySelector(selector);
            if (element)
                return element;
        }
        return null;
    };
    const nameElement = findFirst(selectors.name);
    const priceElement = findFirst(selectors.price);
    const descElement = findFirst(selectors.description);
    const skuElement = findFirst(selectors.sku);
    const imageElement = findFirst(selectors.images);
    return {
        name: nameElement?.textContent.trim(),
        price: parseFloat(priceElement?.textContent?.replace(/[^0-9.]/g, '') || '0') || undefined,
        description: descElement?.textContent.trim(),
        sku: skuElement?.textContent?.trim(),
        images: imageElement ? [imageElement.src] : [],
        url: window.location.href
    };
}
function extractFromTitle() {
    return document.title?.split('|')[0]?.split('-')[0]?.trim();
}
function generateFallbackSKU() {
    const path = window.location.pathname;
    const segments = path.split('/').filter(Boolean);
    const lastSegment = segments[segments.length - 1] || 'unknown';
    const sku = lastSegment.replace(/\.(html?|php|aspx?)$/i, '');
    return `auto-${sku}`;
}

exports.ChatbotAPI = ChatbotAPI;
exports.extractProductFromPage = extractProductFromPage;
exports.formatTimestamp = formatTimestamp;
exports.useChat = useChat;
exports.validateConfig = validateConfig;
//# sourceMappingURL=index.js.map
