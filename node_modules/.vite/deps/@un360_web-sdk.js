import {
  require_jsx_runtime
} from "./chunk-GRWX7YRK.js";
import {
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/@un360/core/dist/index.esm.js
var import_react = __toESM(require_react());
var ChatbotAPI = class {
  constructor(config) {
    this.apiKey = config.apiKey;
    if (config.apiBaseUrl && typeof config.apiBaseUrl === "string" && config.apiBaseUrl.trim() !== "") {
      this.baseUrl = config.apiBaseUrl.trim();
    } else {
      this.baseUrl = "https://sdk-backend-teaa.onrender.com";
    }
    this.productContext = config.productContext;
    this.sessionId = config.sessionId || this.generateSessionId();
    console.log("ChatbotAPI baseUrl:", this.baseUrl);
  }
  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    console.log("Request URL:", url);
    const response = await fetch(url, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        "X-API-Key": this.apiKey,
        ...options.headers
      }
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: "Unknown error" }));
      throw new Error(error.error || `HTTP ${response.status}`);
    }
    return response.json();
  }
  async sendMessage(message) {
    const data = await this.request("/api/v1/chat", {
      method: "POST",
      body: JSON.stringify({
        message,
        product_context: this.productContext,
        session_id: this.sessionId
      })
    });
    return data.response;
  }
  async getSuggestedQuestions() {
    return this.request("/api/v1/questions", {
      method: "POST",
      body: JSON.stringify({
        sku: this.productContext.sku
      })
    });
  }
  async getWidgetConfig() {
    return this.request("/api/v1/config");
  }
  updateProductContext(newContext) {
    this.productContext = { ...this.productContext, ...newContext };
  }
};
function useChat(options) {
  const [messages, setMessages] = (0, import_react.useState)([]);
  const [isLoading, setIsLoading] = (0, import_react.useState)(false);
  const [isBotTyping, setIsBotTyping] = (0, import_react.useState)(false);
  const [suggestedQuestions, setSuggestedQuestions] = (0, import_react.useState)([]);
  const [error, setError] = (0, import_react.useState)(null);
  const apiClientRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    apiClientRef.current = new ChatbotAPI({
      apiKey: options.apiKey,
      productContext: options.productContext,
      apiBaseUrl: options.apiBaseUrl
    });
    const fetchQuestions = async () => {
      try {
        const questions = await apiClientRef.current.getSuggestedQuestions();
        setSuggestedQuestions(questions);
      } catch (err) {
        console.error("Failed to fetch suggested questions:", err);
      }
    };
    fetchQuestions();
  }, [options.apiKey, options.productContext.sku, options.apiBaseUrl]);
  const sendMessage = (0, import_react.useCallback)(async (messageText) => {
    if (!messageText.trim() || !apiClientRef.current)
      return;
    const userMessage = {
      sender: "user",
      text: messageText,
      timestamp: Date.now()
    };
    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setIsBotTyping(true);
    setError(null);
    try {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      const response = await apiClientRef.current.sendMessage(messageText);
      const botMessage = {
        sender: "chatbot",
        text: response,
        timestamp: Date.now()
      };
      setMessages((prev) => [...prev, botMessage]);
    } catch (err) {
      const error2 = err instanceof Error ? err : new Error("Unknown error");
      setError(error2);
      if (options.onError) {
        options.onError(error2);
      }
      const errorMessage = {
        sender: "chatbot",
        text: "Sorry, something went wrong. Please try again.",
        timestamp: Date.now()
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
      setIsBotTyping(false);
    }
  }, [options]);
  const clearMessages = (0, import_react.useCallback)(() => {
    setMessages([]);
    setError(null);
  }, []);
  return {
    messages,
    sendMessage,
    isLoading,
    isBotTyping,
    suggestedQuestions,
    error,
    clearMessages
  };
}
function formatTimestamp(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}
function validateConfig(config) {
  return !!(config.apiKey && config.productContext);
}
function extractProductFromPage() {
  const extractors = [
    extractFromStructuredData,
    extractFromOpenGraph,
    extractFromShopify,
    extractFromWooCommerce,
    extractFromDOM
  ];
  let productData = {};
  for (const extractor of extractors) {
    try {
      const data = extractor();
      productData = { ...productData, ...data };
    } catch (error) {
      console.debug("Extractor failed", extractor.name, error);
    }
  }
  if (!productData.sku) {
    productData.sku = generateFallbackSKU();
  }
  if (!productData.name) {
    productData.name = extractFromTitle() || "Unknown product";
  }
  return productData;
}
function extractFromStructuredData() {
  var _a, _b, _c, _d, _e, _f, _g;
  const scripts = document.querySelectorAll('script[type="application/ld+json"]');
  for (const script of Array.from(scripts)) {
    try {
      const data = JSON.parse(script.textContent || "");
      if (data["@type"] == "Product" || ((_a = data["@type"]) == null ? void 0 : _a.includes("Product"))) {
        return {
          sku: data.sku || data.productID || data.mpn,
          name: data.name,
          description: data.description,
          price: parseFloat(((_b = data.offers) == null ? void 0 : _b.price) || data.price),
          currency: (_c = data.offers) == null ? void 0 : _c.priceCurrency,
          brand: ((_d = data.brand) == null ? void 0 : _d.name) || data.brand,
          images: Array.isArray(data.image) ? data.image : [data.image],
          url: data.url || window.location.href,
          inStock: ((_f = (_e = data.offers) == null ? void 0 : _e.availability) == null ? void 0 : _f.includes("InStock")) || ((_g = data.offers) == null ? void 0 : _g.availability) === "https://schema.org/InStock"
        };
      }
    } catch (error) {
      console.debug("Failed to parse structured data", error);
    }
  }
  return {};
}
function extractFromOpenGraph() {
  const getMeta = (property) => {
    const tag = document.querySelector(`meta[property="${property}"]`) || document.querySelector(`meta[name="${property}"]`);
    return (tag == null ? void 0 : tag.getAttribute("content")) || void 0;
  };
  return {
    name: getMeta("og:title") || getMeta("twitter:title"),
    description: getMeta("og:description") || getMeta("twitter:description") || getMeta("description"),
    images: [getMeta("og:image") || getMeta("twitter:image")].filter(Boolean),
    url: getMeta("og:url") || window.location.href,
    price: parseFloat(getMeta("product:price:amount") || "0") || void 0,
    currency: getMeta("product:price:currency")
  };
}
function extractFromShopify() {
  var _a, _b, _c, _d, _e;
  const shopify = (_b = (_a = window.ShopifyAnalytics) == null ? void 0 : _a.meta) == null ? void 0 : _b.product;
  const product = window.product;
  if (shopify || product) {
    const data = shopify || product;
    return {
      sku: ((_d = (_c = data.variants) == null ? void 0 : _c[0]) == null ? void 0 : _d.sku) || data.sku,
      name: data.title || data.name,
      description: data.description,
      price: data.price ? parseFloat(data.price) / 100 : void 0,
      category: data.type || data.product_type,
      brand: data.vendor,
      images: ((_e = data.images) == null ? void 0 : _e.map((img) => img.src || img)) || [],
      inStock: data.available
    };
  }
  const getShopifyMeta = (name) => {
    var _a2;
    return (_a2 = document.querySelector(`meta[name="shopify-${name}"]`)) == null ? void 0 : _a2.getAttribute("content");
  };
  return {
    sku: getShopifyMeta("product-sku"),
    name: getShopifyMeta("product-name")
  };
}
function extractFromWooCommerce() {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const productElement = document.querySelector('.product, [itemtype*="schema.org/Product"]');
  if (!productElement)
    return {};
  return {
    sku: (_b = (_a = productElement.querySelector(".sku")) == null ? void 0 : _a.textContent) == null ? void 0 : _b.trim(),
    name: (_d = (_c = productElement.querySelector(".product_title, .product-title")) == null ? void 0 : _c.textContent) == null ? void 0 : _d.trim(),
    description: (_f = (_e = productElement.querySelector("woocommerce-product-details__short-description")) == null ? void 0 : _e.textContent) == null ? void 0 : _f.trim(),
    price: parseFloat(((_h = (_g = productElement.querySelector(".price .amount, .price")) == null ? void 0 : _g.textContent) == null ? void 0 : _h.replace(/[^0-9.]/g, "")) || "0") || void 0,
    category: (_j = (_i = productElement.querySelector(".posted_in a")) == null ? void 0 : _i.textContent) == null ? void 0 : _j.trim(),
    brand: (_l = (_k = productElement.querySelector(".brand")) == null ? void 0 : _k.textContent) == null ? void 0 : _l.trim(),
    images: Array.from(productElement.querySelectorAll(".woocommerce-product-gallery__image img")).map((img) => img.src),
    inStock: !productElement.querySelector(".out-of-stock")
  };
}
function extractFromDOM() {
  var _a, _b;
  const selectors = {
    name: [
      "h1.product-title",
      "h1.product.product-name",
      'h1[itemprop="name"]',
      ".product-title",
      ".product-name",
      "h1"
    ],
    price: [
      '[itemprop="price"]',
      ".price",
      ".product-price",
      ".current-price",
      "[data-product-price]"
    ],
    description: [
      '[itemprop="description"]',
      ".product-description",
      ".description",
      ".product-details"
    ],
    sku: [
      '[itemprop="sku"]',
      ".sku",
      ".product-sku",
      "[data-product-sku]"
    ],
    images: [
      '[itemprop="images"]',
      ".product-image img",
      ".main-image img",
      "[data-product-image]"
    ]
  };
  const findFirst = (selectorList) => {
    for (const selector of selectorList) {
      const element = document.querySelector(selector);
      if (element)
        return element;
    }
    return null;
  };
  const nameElement = findFirst(selectors.name);
  const priceElement = findFirst(selectors.price);
  const descElement = findFirst(selectors.description);
  const skuElement = findFirst(selectors.sku);
  const imageElement = findFirst(selectors.images);
  return {
    name: nameElement == null ? void 0 : nameElement.textContent.trim(),
    price: parseFloat(((_a = priceElement == null ? void 0 : priceElement.textContent) == null ? void 0 : _a.replace(/[^0-9.]/g, "")) || "0") || void 0,
    description: descElement == null ? void 0 : descElement.textContent.trim(),
    sku: (_b = skuElement == null ? void 0 : skuElement.textContent) == null ? void 0 : _b.trim(),
    images: imageElement ? [imageElement.src] : [],
    url: window.location.href
  };
}
function extractFromTitle() {
  var _a, _b, _c;
  return (_c = (_b = (_a = document.title) == null ? void 0 : _a.split("|")[0]) == null ? void 0 : _b.split("-")[0]) == null ? void 0 : _c.trim();
}
function generateFallbackSKU() {
  const path = window.location.pathname;
  const segments = path.split("/").filter(Boolean);
  const lastSegment = segments[segments.length - 1] || "unknown";
  const sku = lastSegment.replace(/\.(html?|php|aspx?)$/i, "");
  return `auto-${sku}`;
}

// node_modules/@un360/ui/dist/index.esm.js
var import_react2 = __toESM(require_react());
var ChatHeader = ({ onMinimize, onMaximize, onClose, theme }) => {
  return import_react2.default.createElement(
    "div",
    { style: {
      backgroundColor: theme.primaryColor,
      color: theme.secondaryColor,
      padding: "16px",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center"
    } },
    import_react2.default.createElement("span", { style: { fontWeight: "bold", fontSize: "16px" } }, "Product Assistant"),
    import_react2.default.createElement(
      "div",
      { style: { display: "flex", gap: "8px" } },
      import_react2.default.createElement("button", { onClick: onMinimize, style: buttonStyle }, "−"),
      import_react2.default.createElement("button", { onClick: onMaximize, style: buttonStyle }, "□"),
      import_react2.default.createElement("button", { onClick: onClose, style: buttonStyle }, "×")
    )
  );
};
var buttonStyle = {
  background: "transparent",
  border: "none",
  color: "white",
  fontSize: "20px",
  cursor: "pointer",
  padding: "0 6px"
};
var ChatMessage = ({ message, theme }) => {
  const isUser = message.sender === "user";
  return import_react2.default.createElement(
    "div",
    { style: {
      display: "flex",
      justifyContent: isUser ? "flex-end" : "flex-start",
      marginBottom: "12px"
    } },
    import_react2.default.createElement("div", { style: {
      backgroundColor: isUser ? theme.primaryColor : "#f1f1f1",
      color: isUser ? theme.secondaryColor : "#333",
      padding: "10px 14px",
      borderRadius: "12px",
      maxWidth: "70%",
      wordBreak: "break-word",
      fontSize: "14px",
      lineHeight: "1.4"
    } }, message.text)
  );
};
var SuggestedQuestions = ({ questions, onClick }) => {
  return import_react2.default.createElement(import_react2.default.Fragment, null, questions.map((q) => import_react2.default.createElement("div", { key: q.id, onClick: () => onClick(q.question), style: {
    backgroundColor: "#f9f9f9",
    padding: "12px",
    borderRadius: "8px",
    marginBottom: "8px",
    cursor: "pointer",
    border: "1px solid #e0e0e0",
    transition: "all 0.2s"
  } }, q.question)));
};
var TypingIndicator = () => {
  return import_react2.default.createElement(
    "div",
    { style: { display: "flex", justifyContent: "flex-start", marginBottom: "12px" } },
    import_react2.default.createElement(
      "div",
      { style: {
        backgroundColor: "#f1f1f1",
        padding: "10px 14px",
        borderRadius: "12px",
        fontSize: "14px"
      } },
      import_react2.default.createElement("span", { style: { animation: "pulse 1.5s infinite" } }, "●"),
      import_react2.default.createElement("span", { style: { animation: "pulse 1.5s infinite 0.2s" } }, "●"),
      import_react2.default.createElement("span", { style: { animation: "pulse 1.5s infinite 0.4s" } }, "●")
    )
  );
};
var ChatMessages = ({ messages, isBotTyping, greetingMessage, suggestedQuestions, onQuestionClick, theme }) => {
  const messagesEndRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    var _a;
    (_a = messagesEndRef.current) == null ? void 0 : _a.scrollIntoView({ behavior: "smooth" });
  }, [messages]);
  return import_react2.default.createElement(
    "div",
    { style: {
      flex: 1,
      overflowY: "auto",
      padding: "16px",
      backgroundColor: theme.backgroundColor
    } },
    messages.length === 0 && import_react2.default.createElement("div", { style: { textAlign: "center", color: "#999", padding: "20px", fontStyle: "italic" } }, greetingMessage),
    messages.length === 0 && import_react2.default.createElement(SuggestedQuestions, { questions: suggestedQuestions, onClick: onQuestionClick }),
    messages.map((msg, idx) => import_react2.default.createElement(ChatMessage, { key: idx, message: msg, theme })),
    isBotTyping && import_react2.default.createElement(TypingIndicator, null),
    import_react2.default.createElement("div", { ref: messagesEndRef })
  );
};
var ChatInput = ({ onSend, placeholder, theme }) => {
  const [inputValue, setInputValue] = (0, import_react2.useState)("");
  const handleSend = () => {
    if (inputValue.trim()) {
      onSend(inputValue);
      setInputValue("");
    }
  };
  return import_react2.default.createElement(
    "div",
    { style: {
      padding: "16px",
      borderTop: "1px solid #e0e0e0",
      backgroundColor: theme.secondaryColor,
      display: "flex",
      gap: "8px"
    } },
    import_react2.default.createElement("input", { type: "text", value: inputValue, onChange: (e) => setInputValue(e.target.value), onKeyPress: (e) => e.key === "Enter" && handleSend(), placeholder, style: {
      flex: 1,
      padding: "10px 14px",
      border: "1px solid #e0e0e0",
      borderRadius: "20px",
      fontSize: "14px",
      outline: "none"
    } }),
    import_react2.default.createElement("button", { onClick: handleSend, style: {
      backgroundColor: theme.primaryColor,
      color: theme.secondaryColor,
      border: "none",
      borderRadius: "50%",
      width: "40px",
      height: "40px",
      cursor: "pointer",
      fontSize: "18px"
    } }, "↑")
  );
};
var FloatingButton = ({ onClick, position, theme }) => {
  return import_react2.default.createElement("button", { onClick, style: {
    position: "fixed",
    [position.includes("right") ? "right" : "left"]: "20px",
    [position.includes("bottom") ? "bottom" : "top"]: "20px",
    width: "60px",
    height: "60px",
    borderRadius: "50%",
    border: "none",
    backgroundColor: theme.primaryColor,
    color: theme.secondaryColor,
    fontSize: "24px",
    cursor: "pointer",
    boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
    zIndex: 9999
  } }, "💬");
};
function useClickOutside(ref, handler) {
  (0, import_react2.useEffect)(() => {
    const listener = (event) => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      handler();
    };
    document.addEventListener("mousedown", listener);
    document.addEventListener("touchstart", listener);
    return () => {
      document.removeEventListener("mousedown", listener);
      document.removeEventListener("touchstart", listener);
    };
  }, [ref, handler]);
}
var ChatWidget = ({ apiKey, productContext: providedContext, apiBaseUrl, position = "bottom-right", theme = {}, greetingMessage, placeholder = "Type your message..." }) => {
  const [isOpen, setIsOpen] = (0, import_react2.useState)(false);
  const [isMinimized, setIsMinimized] = (0, import_react2.useState)(false);
  const [isMaximized, setIsMaximized] = (0, import_react2.useState)(false);
  const [productContext, setProductContext] = (0, import_react2.useState)(null);
  const chatRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    if (providedContext) {
      console.log("Using provided product context:", providedContext);
      setProductContext(providedContext);
    } else {
      try {
        console.log("Auto-extracting product data from page...");
        const extracted = extractProductFromPage();
        console.log("Auto-extracted product data:", extracted);
        setProductContext(extracted);
      } catch (error) {
        console.error("Failed to extract product data:", error);
        setProductContext({
          sku: "unknown",
          name: "Unknown Product",
          url: window.location.href
        });
      }
    }
  }, [providedContext]);
  const { messages, sendMessage, isBotTyping, suggestedQuestions } = useChat({
    apiKey,
    productContext: productContext || { sku: "loading", name: "Loading..." },
    // ✅ Provide fallback
    apiBaseUrl
  });
  useClickOutside(chatRef, () => {
    if (!isMinimized) {
      setIsOpen(false);
    }
  });
  if (!productContext) {
    return null;
  }
  const defaultTheme = {
    primaryColor: theme.primaryColor || "#1976d2",
    secondaryColor: theme.secondaryColor || "#fff",
    backgroundColor: theme.backgroundColor || "#f5f5f5",
    fontFamily: theme.fontFamily || "Arial, sans-serif"
  };
  const handleMinimize = () => {
    setIsMinimized(true);
    setIsMaximized(false);
  };
  const handleMaximize = () => {
    setIsMaximized(true);
    setIsMinimized(false);
  };
  const handleClose = () => {
    setIsOpen(false);
    setIsMinimized(false);
    setIsMaximized(false);
  };
  const toggleChat = () => setIsOpen(!isOpen);
  const defaultGreeting = greetingMessage || "Hello! Ask me about this product";
  if (!isOpen) {
    return import_react2.default.createElement(FloatingButton, { onClick: toggleChat, position, theme: defaultTheme });
  }
  return import_react2.default.createElement(
    "div",
    { ref: chatRef, role: "dialog", "aria-label": "Product chat widget", "aria-modal": "true", style: {
      position: "fixed",
      [position.includes("right") ? "right" : "left"]: "20px",
      [position.includes("bottom") ? "bottom" : "top"]: "20px",
      width: isMaximized ? "600px" : "350px",
      height: isMinimized ? "60px" : isMaximized ? "80vh" : "500px",
      backgroundColor: defaultTheme.secondaryColor,
      borderRadius: "12px",
      boxShadow: "0 8px 24px rgba(0,0,0,0.2)",
      display: "flex",
      flexDirection: "column",
      overflow: "hidden",
      transition: "all 0.3s ease",
      fontFamily: defaultTheme.fontFamily,
      zIndex: 1e4
    } },
    import_react2.default.createElement(ChatHeader, { onMinimize: handleMinimize, onMaximize: handleMaximize, onClose: handleClose, theme: defaultTheme }),
    !isMinimized && import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      import_react2.default.createElement(ChatMessages, { messages, isBotTyping, greetingMessage: defaultGreeting, suggestedQuestions, onQuestionClick: (question) => sendMessage(question), theme: defaultTheme }),
      import_react2.default.createElement(ChatInput, { onSend: sendMessage, placeholder, theme: defaultTheme })
    )
  );
};
function useChatUI() {
  const [isOpen, setIsOpen] = (0, import_react2.useState)(false);
  return {
    isOpen,
    setIsOpen
  };
}

// node_modules/@un360/web-sdk/dist/index.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());
var ChatContext = (0, import_react3.createContext)(void 0);
var ChatProvider = ({ apiKey, productId, apiBaseUrl, children }) => {
  const chatData = useChat({ apiKey, productId, apiBaseUrl });
  const value = {
    ...chatData,
    apiKey,
    productId
  };
  return (0, import_jsx_runtime.jsx)(ChatContext.Provider, { value, children });
};
var useChatContext = () => {
  const context = (0, import_react3.useContext)(ChatContext);
  if (!context) {
    throw new Error("useChatContext must be used within ChatProvider");
  }
  return context;
};
export {
  ChatHeader,
  ChatInput,
  ChatMessage as ChatMessageComponent,
  ChatMessages,
  ChatProvider,
  ChatWidget,
  ChatbotAPI,
  FloatingButton,
  SuggestedQuestions,
  TypingIndicator,
  formatTimestamp,
  useChat,
  useChatContext,
  useChatUI,
  useClickOutside,
  validateConfig
};
//# sourceMappingURL=@un360_web-sdk.js.map
